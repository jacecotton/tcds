{"version":3,"sources":["layout/_mixins.scss","legacy/components/_card.scss","legacy/layout/_gap.scss","layout/_variables.scss"],"names":[],"mappings":"AAMI,0BCKF,2BAEI,iDAAA,CAAA,sDAAA,CACA,iBAAA,CAAA,sBAAA,CACA,gCACE,CACF,yBAAA,CAAA,CAAA,wECEF,eCkBK,CDfP,8EAEE,cCaK,CDVP,kBACE,WAAA,CAEA,oBACE,UAAA,CAdJ,oEAEE,eCkBK,CDfP,0EAEE,cCaK,CDVP,gBACE,WAAA,CAEA,kBACE,UAAA,CAdJ,sEAEE,gBCkBK,CDfP,4EAEE,eCaK,CDVP,iBACE,YAAA,CAEA,mBACE,UAAA,CAdJ,oEAEE,gBCkBK,CDfP,0EAEE,eCaK,CDVP,gBACE,YAAA,CAEA,kBACE,WAAA,CAdJ,wEAEE,gBCkBK,CDfP,8EAEE,eCaK,CDVP,kBACE,YAAA,CAEA,oBACE,WAAA","file":"tcds.chrome-2018.css","sourcesContent":["@use \"sass:map\";\n@use \"_variables\" as *;\n@use \"_functions\" as *;\n\n@mixin breakpoint-above($breakpoint) {\n  @if map.has-key($breakpoints, $breakpoint) {\n    @media (min-width: breakpoint($breakpoint)) {\n      @content;\n    }\n  } @else {\n    @media (min-width: #{$breakpoint}) {\n      @content;\n    }\n  }\n}\n\n@mixin breakpoint-below($breakpoint) {\n  @if map.has-key($breakpoints, $breakpoint) {\n    @media (max-width: breakpoint($breakpoint)) {\n      @content;\n    }\n  } @else {\n    @media (max-width: #{$breakpoint}) {\n      @content;\n    }\n  }\n}\n\n@mixin max-width {\n  margin: 0 auto;\n  width: calc(100% - space(\"x-loose\"));\n  max-width: breakpoint(\"x-large\");\n}","@use \"../../_all\" as *;\n\n/**\n * For browsers that do not support container queries (or its polyfill).\n *\n * The strategy here is to simply acquiesce to responsiveness being extrinsic\n * rather than intrinsic, and change the card orientation on screen sizes (or by\n * modifier).\n */\n\n.Card {\n  &:not(#{&}--vertical) {\n    @include breakpoint-above(\"large\") {\n      grid-template-columns: var(--card-media-width, 1fr) 3fr;\n      grid-template-rows: 1fr;\n      grid-template-areas:\n        \"media body\";\n      --card-body-divider: none;\n    }\n  }\n}","@use \"sass:math\";\n@use \"../../_all\" as *;\n\n/**\n * Fake gaps between flex or grid items (immediate children of flex or grid\n * containers) by adding margins. For rows, a left margin will be added to every\n * child except the first. For columns, a top margin will be added to every\n * child except the first. For grids, half the margin value will be added to all\n * sides (since the margin will double up).\n *\n * Note that this is only an approximate imitation of what gap does. With\n * flexbox, wrapping is not accounted for, meaning the first item on a new row\n * will have an awkward blank space at the block start. With grid, there will be\n * excess space around the entire container.\n */\n\n@each $token, $value in $spaces {\n  .gap-#{$token}.row > :not(:first-child),\n  .row-gap-#{$token} > :not(:first-child) {\n    margin-left: $value;\n  }\n\n  .gap-#{$token}.column > :not(:first-child),\n  .column-gap-#{$token} > :not(:first-child) {\n    margin-top: $value;\n  }\n\n  .gap-#{$token}.grid {\n    margin: $value * -1;\n\n    > * {\n      margin: math.div($value, 2);\n    }\n  }\n}","/**\n * Layout design tokens. Each token and its value is stored in a map. Note\n * that each map has a corresponding getter function (see _functions.scss) for\n * easier access. For example, rather than `map.get($sizes, \"small\")`,\n * you can simply use `size(\"small\")`.\n */\n\n/**\n * The global base unit. All layout-related measurements should be an even\n * multiple of this unit.\n */\n$base-unit: 4px;\n\n/**\n * Semantic sizes on a scale of x-small to x-large. Useful for setting widths\n * and heights at the component/element level (for instance to keep size\n * modifiers consistent across components). Not as useful for measurements of\n * larger-scale layouts, which should be flexible and use relative units rather\n * than absolute/static. For fixed, larger-scale layout measurements to use at\n * the macro level, consider breakpoint tokens instead.\n *\n * See: size()\n */\n$sizes: (\n  \"x-small\": $base-unit * 6,\n  \"small\":   $base-unit * 8,\n  \"medium\":  $base-unit * 10,\n  \"large\":   $base-unit * 12,\n  \"x-large\": $base-unit * 14,\n);\n\n/**\n * Semantic spaces on a scale of x-tight to x-loose. Useful for setting margin,\n * padding, gap, etc.\n *\n * See: space()\n */\n$spaces: (\n  \"x-tight\": $base-unit * 1,\n  \"tight\":   $base-unit * 2,\n  \"normal\":  $base-unit * 4,\n  \"loose\":   $base-unit * 6,\n  \"x-loose\": $base-unit * 8,\n);\n\n/**\n * Breakpoints on a scale of small to x-large. Useful for global coordination\n * between elements. However, it is generally recommended to set breakpoints on\n * a case-by-case basis according to works best for the element in question.\n * These are only intended to be optional starting points for when the exact\n * breakpoint doesn't necessarily matter.\n *\n * See: breakpoint()\n */\n$breakpoints: (\n  \"small\": 640px,\n  \"medium\": 768px,\n  \"large\": 1024px,\n  \"x-large\": 1280px,\n);\n\n/**\n * Layers for setting z-index. This is to help manage z-indices from a single\n * source of truth, to ensure elements layer over each other properly, and avoid\n * arbitrary escalation of z-index values. When a new entry is added here,\n * consider its relationship to the other elements listed and adjust each as\n * needed. For instance, a modal should be on top of a sticky header.\n *\n * Note that negative values, 1, and 2 are reserved. They are allowed to be used\n * anywhere and do not need to be systematized, as they are often only useful\n * for setting z-indices relative to the stacking context of the element in\n * question.\n *\n * See: layer()\n */\n$layers: (\n  \"modal\": 4,\n  \"sticky-header\": 3,\n);"]}