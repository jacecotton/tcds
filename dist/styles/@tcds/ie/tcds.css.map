{"version":3,"sources":["@tcds/ie/components/hero.scss","@tcds/ie/layout/utilities.scss","@tcds/layout/_variables.scss"],"names":[],"mappings":"AAMA,MACE,UAAA,CCUA,wEAEE,eCkBK,CDfP,8EAEE,cCaK,CDVP,oBACE,UAAA,CAXF,oEAEE,eCkBK,CDfP,0EAEE,cCaK,CDVP,kBACE,UAAA,CAXF,sEAEE,gBCkBK,CDfP,4EAEE,eCaK,CDVP,mBACE,UAAA,CAXF,oEAEE,gBCkBK,CDfP,0EAEE,eCaK,CDVP,kBACE,WAAA,CAXF,wEAEE,gBCkBK,CDfP,8EAEE,eCaK,CDVP,oBACE,WAAA,CAWJ,MACE,oBAAA","file":"tcds.css","sourcesContent":["/**\n * A flexbox bug in IE 11 makes `align-items: center` not work on elements with\n * only a `min-height`. A workaround is to set a `height` less than the\n * `min-height`.\n */\n\n.Hero {\n  height: 0px; // 1\n}","@use \"sass:math\";\n@use \"../../_all\" as *;\n\n/**\n * Fake gaps between flex or grid items (immediate children of flex or grid\n * containers) by adding margins. For rows, a left margin will be added to every\n * child except the first. For columns, a top margin will be added to every\n * child except the first. For grids, half the margin value will be added to all\n * sides (since the margin will double up).\n *\n * Note that this is only an approximate imitation of what gap does. With\n * flexbox, wrapping is not accounted for, meaning the first item on a new row\n * will have an awkward blank space at the block start. With grid, there will be\n * excess space around the entire container.\n */\n\n@each $token, $value in $spaces {\n  .gap-#{$token}.row > :not(:first-child),\n  .row-gap-#{$token} > :not(:first-child) {\n    margin-left: $value;\n  }\n\n  .gap-#{$token}.column > :not(:first-child),\n  .column-gap-#{$token} > :not(:first-child) {\n    margin-top: $value;\n  }\n\n  .gap-#{$token}.grid > * {\n    margin: math.div($value, 2);\n  }\n}\n\n/**\n * The features of the grid utility cannot be faked for IE. Instead, make each\n * grid container created with the utility a simple 1-column layout. Multiple\n * columns should be treated as a progressive enhancement beyond both IE and\n * smaller screens.\n */\n\n.grid {\n  -ms-grid-columns: 1fr;\n}","/**\n * Layout design tokens. Each token and its value is stored in a map. Note\n * that each map has a corresponding getter function (see _functions.scss) for\n * easier access. For example, rather than `map.get($sizes, \"small\")`,\n * you can simply use `size(\"small\")`.\n */\n\n/**\n * The global base unit. All layout-related measurements should be an even\n * multiple of this unit.\n */\n$base-unit: 4px;\n\n/**\n * Semantic sizes on a scale of x-small to x-large. Useful for setting widths\n * and heights at the component/element level (for instance to keep size\n * modifiers consistent across components). Not as useful for measurements of\n * larger-scale layouts, which should be flexible and use relative units rather\n * than absolute/static. For fixed, larger-scale layout measurements to use at\n * the macro level, consider breakpoint tokens instead.\n *\n * See: size()\n */\n$sizes: (\n  \"x-small\": $base-unit * 6,\n  \"small\":   $base-unit * 8,\n  \"medium\":  $base-unit * 10,\n  \"large\":   $base-unit * 12,\n  \"x-large\": $base-unit * 14,\n);\n\n/**\n * Semantic spaces on a scale of x-tight to x-loose. Useful for setting margin,\n * padding, gap, etc.\n *\n * See: space()\n */\n$spaces: (\n  \"x-tight\": $base-unit * 1,\n  \"tight\":   $base-unit * 2,\n  \"normal\":  $base-unit * 4,\n  \"loose\":   $base-unit * 6,\n  \"x-loose\": $base-unit * 8,\n);\n\n/**\n * Breakpoints on a scale of small to x-large. Useful for global coordination\n * between elements. However, it is generally recommended to set breakpoints on\n * a case-by-case basis according to works best for the element in question.\n * These are only intended to be optional starting points for when the exact\n * breakpoint doesn't necessarily matter.\n *\n * See: breakpoint()\n */\n$breakpoints: (\n  \"small\": 640px,\n  \"medium\": 768px,\n  \"large\": 1024px,\n  \"x-large\": 1280px,\n);\n\n/**\n * Layers for setting z-index. This is to help manage z-indices from a single\n * source of truth, to ensure elements layer over each other properly, and avoid\n * arbitrary escalation of z-index values. When a new entry is added here,\n * consider its relationship to the other elements listed and adjust each as\n * needed. For instance, a modal should be on top of a sticky header.\n *\n * Note that negative values, 1, and 2 are reserved. They are allowed to be used\n * anywhere and do not need to be systematized, as they are often only useful\n * for setting z-indices relative to the stacking context of the element in\n * question.\n *\n * See: layer()\n */\n$layers: (\n  \"modal\": 4,\n  \"sticky-header\": 3,\n);"]}